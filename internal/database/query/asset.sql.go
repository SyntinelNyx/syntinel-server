// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: asset.sql

package query

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAsset = `-- name: AddAsset :exec
WITH inserted_sysinfo AS (
  INSERT INTO system_information (
    hostname,
    uptime,
    boot_time,
    procs,
    os,
    platform,
    platform_family,
    platform_version,
    kernel_version,
    kernel_arch,
    virtualization_system,
    virtualization_role,
    host_id,
    cpu_vendor_id,
    cpu_cores,
    cpu_model_name,
    cpu_mhz,
    cpu_cache_size,
    memory,
    disk
  ) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18, $19, $20
  )
  RETURNING id
)
INSERT INTO assets (
  asset_id,
  ip_address,
  sysinfo_id,
  root_account_id
) VALUES (
  $21, $22, (SELECT id FROM inserted_sysinfo), $23
)
`

type AddAssetParams struct {
	Hostname             pgtype.Text
	Uptime               pgtype.Int8
	BootTime             pgtype.Int8
	Procs                pgtype.Int8
	Os                   pgtype.Text
	Platform             pgtype.Text
	PlatformFamily       pgtype.Text
	PlatformVersion      pgtype.Text
	KernelVersion        pgtype.Text
	KernelArch           pgtype.Text
	VirtualizationSystem pgtype.Text
	VirtualizationRole   pgtype.Text
	HostID               pgtype.Text
	CpuVendorID          pgtype.Text
	CpuCores             pgtype.Int4
	CpuModelName         pgtype.Text
	CpuMhz               pgtype.Float8
	CpuCacheSize         pgtype.Int4
	Memory               pgtype.Int8
	Disk                 pgtype.Int8
	AssetID              pgtype.UUID
	IpAddress            netip.Addr
	RootAccountID        pgtype.UUID
}

func (q *Queries) AddAsset(ctx context.Context, arg AddAssetParams) error {
	_, err := q.db.Exec(ctx, addAsset,
		arg.Hostname,
		arg.Uptime,
		arg.BootTime,
		arg.Procs,
		arg.Os,
		arg.Platform,
		arg.PlatformFamily,
		arg.PlatformVersion,
		arg.KernelVersion,
		arg.KernelArch,
		arg.VirtualizationSystem,
		arg.VirtualizationRole,
		arg.HostID,
		arg.CpuVendorID,
		arg.CpuCores,
		arg.CpuModelName,
		arg.CpuMhz,
		arg.CpuCacheSize,
		arg.Memory,
		arg.Disk,
		arg.AssetID,
		arg.IpAddress,
		arg.RootAccountID,
	)
	return err
}

const getAllAssetIP = `-- name: GetAllAssetIP :many
SELECT ip_address
FROM assets
WHERE root_account_id = $1
`

func (q *Queries) GetAllAssetIP(ctx context.Context, rootAccountID pgtype.UUID) ([]netip.Addr, error) {
	rows, err := q.db.Query(ctx, getAllAssetIP, rootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []netip.Addr
	for rows.Next() {
		var ip_address netip.Addr
		if err := rows.Scan(&ip_address); err != nil {
			return nil, err
		}
		items = append(items, ip_address)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAssets = `-- name: GetAllAssets :many
SELECT
  a.asset_id,
  s.hostname,
  s.os,
  s.platform_version,
  a.ip_address,
  s.created_at
FROM assets a
JOIN system_information s ON a.sysinfo_id = s.id
WHERE a.root_account_id = $1
`

type GetAllAssetsRow struct {
	AssetID         pgtype.UUID
	Hostname        pgtype.Text
	Os              pgtype.Text
	PlatformVersion pgtype.Text
	IpAddress       netip.Addr
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) GetAllAssets(ctx context.Context, rootAccountID pgtype.UUID) ([]GetAllAssetsRow, error) {
	rows, err := q.db.Query(ctx, getAllAssets, rootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAssetsRow
	for rows.Next() {
		var i GetAllAssetsRow
		if err := rows.Scan(
			&i.AssetID,
			&i.Hostname,
			&i.Os,
			&i.PlatformVersion,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssets = `-- name: GetAssets :many
SELECT asset_id, ip_address, sysinfo_id, root_account_id, registered_at FROM assets
WHERE root_account_id = $1
`

func (q *Queries) GetAssets(ctx context.Context, rootAccountID pgtype.UUID) ([]Asset, error) {
	rows, err := q.db.Query(ctx, getAssets, rootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.AssetID,
			&i.IpAddress,
			&i.SysinfoID,
			&i.RootAccountID,
			&i.RegisteredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstAssetIP = `-- name: GetFirstAssetIP :one
SELECT ip_address
FROM assets
ORDER BY registered_at
LIMIT 1
`

func (q *Queries) GetFirstAssetIP(ctx context.Context) (netip.Addr, error) {
	row := q.db.QueryRow(ctx, getFirstAssetIP)
	var ip_address netip.Addr
	err := row.Scan(&ip_address)
	return ip_address, err
}

const getIPByAssetID = `-- name: GetIPByAssetID :one
SELECT ip_address
FROM assets
WHERE asset_id = $1 AND root_account_id = $2
`

type GetIPByAssetIDParams struct {
	AssetID       pgtype.UUID
	RootAccountID pgtype.UUID
}

func (q *Queries) GetIPByAssetID(ctx context.Context, arg GetIPByAssetIDParams) (netip.Addr, error) {
	row := q.db.QueryRow(ctx, getIPByAssetID, arg.AssetID, arg.RootAccountID)
	var ip_address netip.Addr
	err := row.Scan(&ip_address)
	return ip_address, err
}
