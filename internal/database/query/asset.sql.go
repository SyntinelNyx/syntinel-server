// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: asset.sql

package query

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAsset = `-- name: AddAsset :exec
WITH inserted_sysinfo AS (
  INSERT INTO system_information (
    hostname,
    uptime,
    boot_time,
    procs,
    os,
    platform,
    platform_family,
    platform_version,
    kernel_version,
    kernel_arch,
    virtualization_system,
    virtualization_role,
    host_id,
    cpu_vendor_id,
    cpu_cores,
    cpu_model_name,
    cpu_mhz,
    cpu_cache_size,
    memory,
    disk
  ) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18, $19, $20
  )
  RETURNING id
)
INSERT INTO assets (
  asset_id,
  ip_address,
  sysinfo_id,
  root_account_id
) VALUES (
  $21, $22, (SELECT id FROM inserted_sysinfo), $23
)
`

type AddAssetParams struct {
	Hostname             pgtype.Text
	Uptime               pgtype.Int8
	BootTime             pgtype.Int8
	Procs                pgtype.Int8
	Os                   pgtype.Text
	Platform             pgtype.Text
	PlatformFamily       pgtype.Text
	PlatformVersion      pgtype.Text
	KernelVersion        pgtype.Text
	KernelArch           pgtype.Text
	VirtualizationSystem pgtype.Text
	VirtualizationRole   pgtype.Text
	HostID               pgtype.Text
	CpuVendorID          pgtype.Text
	CpuCores             pgtype.Int4
	CpuModelName         pgtype.Text
	CpuMhz               pgtype.Float8
	CpuCacheSize         pgtype.Int4
	Memory               pgtype.Int8
	Disk                 pgtype.Int8
	AssetID              pgtype.UUID
	IpAddress            netip.Addr
	RootAccountID        pgtype.UUID
}

func (q *Queries) AddAsset(ctx context.Context, arg AddAssetParams) error {
	_, err := q.db.Exec(ctx, addAsset,
		arg.Hostname,
		arg.Uptime,
		arg.BootTime,
		arg.Procs,
		arg.Os,
		arg.Platform,
		arg.PlatformFamily,
		arg.PlatformVersion,
		arg.KernelVersion,
		arg.KernelArch,
		arg.VirtualizationSystem,
		arg.VirtualizationRole,
		arg.HostID,
		arg.CpuVendorID,
		arg.CpuCores,
		arg.CpuModelName,
		arg.CpuMhz,
		arg.CpuCacheSize,
		arg.Memory,
		arg.Disk,
		arg.AssetID,
		arg.IpAddress,
		arg.RootAccountID,
	)
	return err
}

const getAllAssets = `-- name: GetAllAssets :many
SELECT a.asset_id,
  s.hostname,
  s.os,
  s.platform_version,
  a.ip_address,
  s.created_at
FROM assets a
JOIN system_information s ON a.sysinfo_id = s.id
WHERE a.root_account_id = $1
`

type GetAllAssetsRow struct {
	AssetID         pgtype.UUID
	Hostname        pgtype.Text
	Os              pgtype.Text
	PlatformVersion pgtype.Text
	IpAddress       netip.Addr
	CreatedAt       pgtype.Timestamptz
}

func (q *Queries) GetAllAssets(ctx context.Context, rootAccountID pgtype.UUID) ([]GetAllAssetsRow, error) {
	rows, err := q.db.Query(ctx, getAllAssets, rootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAssetsRow
	for rows.Next() {
		var i GetAllAssetsRow
		if err := rows.Scan(
			&i.AssetID,
			&i.Hostname,
			&i.Os,
			&i.PlatformVersion,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAsset = `-- name: GetAsset :one
SELECT asset_id, ip_address, sysinfo_id, root_account_id, registered_at FROM assets
WHERE root_account_id = $1
`

func (q *Queries) GetAsset(ctx context.Context, rootAccountID pgtype.UUID) (Asset, error) {
	row := q.db.QueryRow(ctx, getAsset, rootAccountID)
	var i Asset
	err := row.Scan(
		&i.AssetID,
		&i.IpAddress,
		&i.SysinfoID,
		&i.RootAccountID,
		&i.RegisteredAt,
	)
	return i, err
}

const getAssetInfoById = `-- name: GetAssetInfoById :one
SELECT
  a.asset_id,
  a.ip_address,
  a.sysinfo_id,
  a.root_account_id,
  a.registered_at,
  s.id AS system_info_id,
  s.hostname,
  s.uptime,
  s.boot_time,
  s.procs,
  s.os,
  s.platform,
  s.platform_family,
  s.platform_version,
  s.kernel_version,
  s.kernel_arch,
  s.virtualization_system,
  s.virtualization_role,
  s.host_id,
  s.cpu_vendor_id,
  s.cpu_cores,
  s.cpu_model_name,
  s.cpu_mhz,
  s.cpu_cache_size,
  s.memory,
  s.disk,
  s.created_at AS system_info_created_at
FROM assets a
JOIN system_information s ON a.sysinfo_id = s.id
WHERE a.asset_id = $1
`

type GetAssetInfoByIdRow struct {
	AssetID              pgtype.UUID
	IpAddress            netip.Addr
	SysinfoID            pgtype.UUID
	RootAccountID        pgtype.UUID
	RegisteredAt         pgtype.Timestamptz
	SystemInfoID         pgtype.UUID
	Hostname             pgtype.Text
	Uptime               pgtype.Int8
	BootTime             pgtype.Int8
	Procs                pgtype.Int8
	Os                   pgtype.Text
	Platform             pgtype.Text
	PlatformFamily       pgtype.Text
	PlatformVersion      pgtype.Text
	KernelVersion        pgtype.Text
	KernelArch           pgtype.Text
	VirtualizationSystem pgtype.Text
	VirtualizationRole   pgtype.Text
	HostID               pgtype.Text
	CpuVendorID          pgtype.Text
	CpuCores             pgtype.Int4
	CpuModelName         pgtype.Text
	CpuMhz               pgtype.Float8
	CpuCacheSize         pgtype.Int4
	Memory               pgtype.Int8
	Disk                 pgtype.Int8
	SystemInfoCreatedAt  pgtype.Timestamptz
}

func (q *Queries) GetAssetInfoById(ctx context.Context, assetID pgtype.UUID) (GetAssetInfoByIdRow, error) {
	row := q.db.QueryRow(ctx, getAssetInfoById, assetID)
	var i GetAssetInfoByIdRow
	err := row.Scan(
		&i.AssetID,
		&i.IpAddress,
		&i.SysinfoID,
		&i.RootAccountID,
		&i.RegisteredAt,
		&i.SystemInfoID,
		&i.Hostname,
		&i.Uptime,
		&i.BootTime,
		&i.Procs,
		&i.Os,
		&i.Platform,
		&i.PlatformFamily,
		&i.PlatformVersion,
		&i.KernelVersion,
		&i.KernelArch,
		&i.VirtualizationSystem,
		&i.VirtualizationRole,
		&i.HostID,
		&i.CpuVendorID,
		&i.CpuCores,
		&i.CpuModelName,
		&i.CpuMhz,
		&i.CpuCacheSize,
		&i.Memory,
		&i.Disk,
		&i.SystemInfoCreatedAt,
	)
	return i, err
}

const getAssetsByHostnames = `-- name: GetAssetsByHostnames :many
SELECT 
  a.asset_id, 
  a.ip_address, 
  s.os,
  a.root_account_id,
  s.hostname
FROM assets a
JOIN system_information s ON s.id = a.sysinfo_id
WHERE s.hostname = ANY($1::text[])
`

type GetAssetsByHostnamesRow struct {
	AssetID       pgtype.UUID
	IpAddress     netip.Addr
	Os            pgtype.Text
	RootAccountID pgtype.UUID
	Hostname      pgtype.Text
}

func (q *Queries) GetAssetsByHostnames(ctx context.Context, hostnames []string) ([]GetAssetsByHostnamesRow, error) {
	rows, err := q.db.Query(ctx, getAssetsByHostnames, hostnames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetsByHostnamesRow
	for rows.Next() {
		var i GetAssetsByHostnamesRow
		if err := rows.Scan(
			&i.AssetID,
			&i.IpAddress,
			&i.Os,
			&i.RootAccountID,
			&i.Hostname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
