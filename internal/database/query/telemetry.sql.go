// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: telemetry.sql

package query

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const getLatestTelemetryALL = `-- name: GetLatestTelemetryALL :many
SELECT 
    a.asset_id,
    a.ip_address,
    si.hostname,
<<<<<<< HEAD
    t.telemetry_time,
=======
    t.scan_time,
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
    t.cpu_usage,
    t.mem_used_percent,
    t.disk_used_percent
FROM telemetry t
JOIN telemetry_asset ta ON t.telemetry_id = ta.telemetry_id
JOIN assets a ON ta.asset_id = a.asset_id
JOIN system_information si ON a.sysinfo_id = si.id
WHERE t.scan_time = (
    SELECT MAX(t2.scan_time)
    FROM telemetry t2
    JOIN telemetry_asset ta2 ON t2.telemetry_id = ta2.telemetry_id
    WHERE ta2.asset_id = ta.asset_id
)
ORDER BY a.ip_address
`

type GetLatestTelemetryALLRow struct {
	AssetID         pgtype.UUID
	IpAddress       netip.Addr
	Hostname        pgtype.Text
<<<<<<< HEAD
	TelemetryTime   pgtype.Timestamptz
=======
	ScanTime        pgtype.Timestamptz
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
	CpuUsage        float64
	MemUsedPercent  float64
	DiskUsedPercent float64
}

func (q *Queries) GetLatestTelemetryALL(ctx context.Context) ([]GetLatestTelemetryALLRow, error) {
	rows, err := q.db.Query(ctx, getLatestTelemetryALL)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestTelemetryALLRow
	for rows.Next() {
		var i GetLatestTelemetryALLRow
		if err := rows.Scan(
			&i.AssetID,
			&i.IpAddress,
			&i.Hostname,
<<<<<<< HEAD
			&i.TelemetryTime,
=======
			&i.ScanTime,
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
			&i.CpuUsage,
			&i.MemUsedPercent,
			&i.DiskUsedPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTelemetryByTime = `-- name: GetTelemetryByTime :one
SELECT 
<<<<<<< HEAD
    time_bucket($1 , t.scan_time) AS hour,
=======
    time_bucket('1 hour', t.scan_time) AS hour,
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
    ta.asset_id,
    a.ip_address,
    AVG(t.cpu_usage) AS avg_cpu,
    AVG(t.mem_used_percent) AS avg_mem,
    AVG(t.disk_used_percent) AS avg_disk
FROM telemetry t
JOIN telemetry_asset ta ON t.telemetry_id = ta.telemetry_id
JOIN assets a ON ta.asset_id = a.asset_id
JOIN root_accounts ra ON ta.root_account_id = ra.account_id
<<<<<<< HEAD
WHERE t.scan_time > NOW() - INTERVAL $2
=======
WHERE t.scan_time > NOW() - INTERVAL '24 hours'
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
GROUP BY hour, ta.asset_id, a.ip_address
ORDER BY hour DESC, ta.asset_id
`

<<<<<<< HEAD
type GetTelemetryByTimeParams struct {
	TimeBucket interface{}
	Column2    pgtype.Interval
}

=======
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
type GetTelemetryByTimeRow struct {
	Hour      interface{}
	AssetID   pgtype.UUID
	IpAddress netip.Addr
	AvgCpu    float64
	AvgMem    float64
	AvgDisk   float64
}

<<<<<<< HEAD
func (q *Queries) GetTelemetryByTime(ctx context.Context, arg GetTelemetryByTimeParams) (GetTelemetryByTimeRow, error) {
	row := q.db.QueryRow(ctx, getTelemetryByTime, arg.TimeBucket, arg.Column2)
=======
func (q *Queries) GetTelemetryByTime(ctx context.Context) (GetTelemetryByTimeRow, error) {
	row := q.db.QueryRow(ctx, getTelemetryByTime)
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
	var i GetTelemetryByTimeRow
	err := row.Scan(
		&i.Hour,
		&i.AssetID,
		&i.IpAddress,
		&i.AvgCpu,
		&i.AvgMem,
		&i.AvgDisk,
	)
	return i, err
}
<<<<<<< HEAD

const insertTelemetryData = `-- name: InsertTelemetryData :many
WITH inserted_telemetry AS (
    INSERT INTO telemetry (
        telemetry_id,
        telemetry_time,
        cpu_usage,
        mem_total,
        mem_available,
        mem_used,
        mem_used_percent,
        disk_total,
        disk_free,
        disk_used,
        disk_used_percent
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
    )
    RETURNING telemetry_id, telemetry_time
)
INSERT INTO telemetry_asset (
    telemetry_id,
    asset_id,
    root_account_id
) VALUES (
    (SELECT telemetry_id FROM inserted_telemetry),
    $12,
    $13
)
RETURNING (SELECT telemetry_id FROM inserted_telemetry)
`

type InsertTelemetryDataParams struct {
	TelemetryID     pgtype.UUID
	TelemetryTime   pgtype.Timestamptz
	CpuUsage        float64
	MemTotal        int64
	MemAvailable    int64
	MemUsed         int64
	MemUsedPercent  float64
	DiskTotal       int64
	DiskFree        int64
	DiskUsed        int64
	DiskUsedPercent float64
	AssetID         pgtype.UUID
	RootAccountID   pgtype.UUID
}

func (q *Queries) InsertTelemetryData(ctx context.Context, arg InsertTelemetryDataParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, insertTelemetryData,
		arg.TelemetryID,
		arg.TelemetryTime,
		arg.CpuUsage,
		arg.MemTotal,
		arg.MemAvailable,
		arg.MemUsed,
		arg.MemUsedPercent,
		arg.DiskTotal,
		arg.DiskFree,
		arg.DiskUsed,
		arg.DiskUsedPercent,
		arg.AssetID,
		arg.RootAccountID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var telemetry_id pgtype.UUID
		if err := rows.Scan(&telemetry_id); err != nil {
			return nil, err
		}
		items = append(items, telemetry_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
=======
>>>>>>> 0837eca9844d7ee6c1ae0da36e420852fd57e7a2
