// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: telemetry.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAssetUptime = `-- name: GetAssetUptime :many
WITH asset_uptime_diff AS (
  SELECT
    ta.asset_id,
    ta.telemetry_id,
    t.telemetry_time,
    LAG(t.telemetry_time) OVER (PARTITION BY ta.asset_id ORDER BY t.telemetry_time) AS prev_telemetry_time,
    EXTRACT(EPOCH FROM (t.telemetry_time - LAG(t.telemetry_time) OVER (PARTITION BY ta.asset_id ORDER BY t.telemetry_time))) AS time_diff
  FROM
    telemetry_asset ta
  JOIN
    telemetry t ON ta.telemetry_id = t.telemetry_id
  WHERE
    ta.root_account_id = $1
    AND t.telemetry_time > NOW() - INTERVAL '30 days'  -- Optional: filter by the past 30 days
)
SELECT
  asset_id,
  SUM(CASE
        WHEN time_diff <= 300 THEN time_diff  -- 300 seconds = 5 minutes
        ELSE 0  -- Downtime: Ignore gaps larger than 5 minutes
      END) AS total_uptime_seconds
FROM
  asset_uptime_diff
WHERE
  prev_telemetry_time IS NOT NULL
GROUP BY
  asset_id
`

type GetAssetUptimeRow struct {
	AssetID            pgtype.UUID
	TotalUptimeSeconds int64
}

func (q *Queries) GetAssetUptime(ctx context.Context, rootAccountID pgtype.UUID) ([]GetAssetUptimeRow, error) {
	rows, err := q.db.Query(ctx, getAssetUptime, rootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetUptimeRow
	for rows.Next() {
		var i GetAssetUptimeRow
		if err := rows.Scan(&i.AssetID, &i.TotalUptimeSeconds); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetUsageByTime = `-- name: GetAssetUsageByTime :many
SELECT
    t.telemetry_time,
    t.cpu_usage,
    t.mem_total,
    t.mem_available,
    t.mem_used,
    t.mem_used_percent,
    t.disk_total,
    t.disk_free,
    t.disk_used,
    t.disk_used_percent
FROM
    telemetry_asset ta
JOIN
    telemetry t ON ta.telemetry_id = t.telemetry_id
WHERE
    ta.asset_id = $1  -- Replace $1 with the asset_id
    AND ta.root_account_id = $2  -- Replace $2 with the root_account_id
    AND t.telemetry_time > NOW() - INTERVAL '30 days'  -- Optional: filter by the past 30 days
ORDER BY
    t.telemetry_time ASC
`

type GetAssetUsageByTimeParams struct {
	AssetID       pgtype.UUID
	RootAccountID pgtype.UUID
}

type GetAssetUsageByTimeRow struct {
	TelemetryTime   pgtype.Timestamptz
	CpuUsage        float64
	MemTotal        int64
	MemAvailable    int64
	MemUsed         int64
	MemUsedPercent  float64
	DiskTotal       int64
	DiskFree        int64
	DiskUsed        int64
	DiskUsedPercent float64
}

func (q *Queries) GetAssetUsageByTime(ctx context.Context, arg GetAssetUsageByTimeParams) ([]GetAssetUsageByTimeRow, error) {
	rows, err := q.db.Query(ctx, getAssetUsageByTime, arg.AssetID, arg.RootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetUsageByTimeRow
	for rows.Next() {
		var i GetAssetUsageByTimeRow
		if err := rows.Scan(
			&i.TelemetryTime,
			&i.CpuUsage,
			&i.MemTotal,
			&i.MemAvailable,
			&i.MemUsed,
			&i.MemUsedPercent,
			&i.DiskTotal,
			&i.DiskFree,
			&i.DiskUsed,
			&i.DiskUsedPercent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTelemetryData = `-- name: InsertTelemetryData :exec
WITH inserted_telemetry AS (
    INSERT INTO telemetry (
        cpu_usage,
        mem_total,
        mem_available,
        mem_used,
        mem_used_percent,
        disk_total,
        disk_free,
        disk_used,
        disk_used_percent
    ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9
    )
    RETURNING telemetry_id, telemetry_time
)
INSERT INTO telemetry_asset (
    telemetry_time,
    telemetry_id,
    asset_id,
    root_account_id
) 
SELECT 
    telemetry_time,
    telemetry_id,
    $10 AS asset_id,
    $11 AS root_account_id
FROM inserted_telemetry
`

type InsertTelemetryDataParams struct {
	CpuUsage        float64
	MemTotal        int64
	MemAvailable    int64
	MemUsed         int64
	MemUsedPercent  float64
	DiskTotal       int64
	DiskFree        int64
	DiskUsed        int64
	DiskUsedPercent float64
	AssetID         pgtype.UUID
	RootAccountID   pgtype.UUID
}

func (q *Queries) InsertTelemetryData(ctx context.Context, arg InsertTelemetryDataParams) error {
	_, err := q.db.Exec(ctx, insertTelemetryData,
		arg.CpuUsage,
		arg.MemTotal,
		arg.MemAvailable,
		arg.MemUsed,
		arg.MemUsedPercent,
		arg.DiskTotal,
		arg.DiskFree,
		arg.DiskUsed,
		arg.DiskUsedPercent,
		arg.AssetID,
		arg.RootAccountID,
	)
	return err
}
