// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: perms.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRole = `-- name: AddRole :exec
WITH inserted_role AS (
	INSERT INTO roles (role_name)
	VALUES ($1)
	RETURNING role_id
),
inserted_permission AS (
	INSERT INTO permissions (
	    is_administrator, view_assets, manage_assets, view_modules, 
	create_modules, manage_modules, view_scans, start_scans
	)
	VALUES ($2, $3, $4, $5, $6, $7, $8, $9)
	RETURNING permission_id
	)
INSERT INTO roles_permissions (role_id, permission_id)
SELECT inserted_role.role_id, inserted_permission.permission_id
FROM inserted_role, inserted_permission
`

type AddRoleParams struct {
	RoleName        string
	IsAdministrator pgtype.Bool
	ViewAssets      pgtype.Bool
	ManageAssets    pgtype.Bool
	ViewModules     pgtype.Bool
	CreateModules   pgtype.Bool
	ManageModules   pgtype.Bool
	ViewScans       pgtype.Bool
	StartScans      pgtype.Bool
}

func (q *Queries) AddRole(ctx context.Context, arg AddRoleParams) error {
	_, err := q.db.Exec(ctx, addRole,
		arg.RoleName,
		arg.IsAdministrator,
		arg.ViewAssets,
		arg.ManageAssets,
		arg.ViewModules,
		arg.CreateModules,
		arg.ManageModules,
		arg.ViewScans,
		arg.StartScans,
	)
	return err
}

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO iam_user_roles (iam_account_id, role_id)
SELECT ia.account_id, r.role_id
FROM iam_accounts ia
JOIN roles r ON r.role_name = $1
WHERE ia.username = $2
`

type AssignRoleToUserParams struct {
	RoleName string
	Username string
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUser, arg.RoleName, arg.Username)
	return err
}

const getAllRoles = `-- name: GetAllRoles :many
SELECT role_name FROM roles WHERE is_deleted = FALSE
`

func (q *Queries) GetAllRoles(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var role_name string
		if err := rows.Scan(&role_name); err != nil {
			return nil, err
		}
		items = append(items, role_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT role_id, role_name, is_deleted FROM roles WHERE role_name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, roleName string) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, roleName)
	var i Role
	err := row.Scan(&i.RoleID, &i.RoleName, &i.IsDeleted)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :one
SELECT p.permission_id, p.is_administrator, p.view_assets, p.manage_assets, p.view_modules, p.create_modules, p.manage_modules, p.view_scans, p.start_scans FROM roles r
JOIN
    roles_permissions rp ON r.role_id = rp.role_id
JOIN
    permissions p ON rp.permission_id = p.permission_id
WHERE
    r.role_name = $1
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleName string) (Permission, error) {
	row := q.db.QueryRow(ctx, getRolePermissions, roleName)
	var i Permission
	err := row.Scan(
		&i.PermissionID,
		&i.IsAdministrator,
		&i.ViewAssets,
		&i.ManageAssets,
		&i.ViewModules,
		&i.CreateModules,
		&i.ManageModules,
		&i.ViewScans,
		&i.StartScans,
	)
	return i, err
}

const getUserPermissions = `-- name: GetUserPermissions :one
SELECT p.permission_id, p.is_administrator, p.view_assets, p.manage_assets, p.view_modules, p.create_modules, p.manage_modules, p.view_scans, p.start_scans FROM iam_user_permissions iup
JOIN 
    permissions p ON iup.permission_id = p.permission_id
JOIN 
    iam_accounts ia ON iup.iam_account_id = ia.account_id
WHERE 
    ia.account_id = $1
`

func (q *Queries) GetUserPermissions(ctx context.Context, accountID pgtype.UUID) (Permission, error) {
	row := q.db.QueryRow(ctx, getUserPermissions, accountID)
	var i Permission
	err := row.Scan(
		&i.PermissionID,
		&i.IsAdministrator,
		&i.ViewAssets,
		&i.ManageAssets,
		&i.ViewModules,
		&i.CreateModules,
		&i.ManageModules,
		&i.ViewScans,
		&i.StartScans,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :one
SELECT role_name FROM roles r
JOIN
    iam_user_roles iur ON r.role_id = iur.role_id 
JOIN
    iam_accounts ia ON iur.iam_account_id = ia.account_id
WHERE
    ia.username = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, username string) (string, error) {
	row := q.db.QueryRow(ctx, getUserRoles, username)
	var role_name string
	err := row.Scan(&role_name)
	return role_name, err
}

const reactivateRole = `-- name: ReactivateRole :exec
UPDATE roles
SET is_deleted = FALSE
WHERE role_name = $1
`

func (q *Queries) ReactivateRole(ctx context.Context, roleName string) error {
	_, err := q.db.Exec(ctx, reactivateRole, roleName)
	return err
}

const removeRole = `-- name: RemoveRole :exec
UPDATE roles
SET is_deleted = TRUE
WHERE role_name = $1
`

func (q *Queries) RemoveRole(ctx context.Context, roleName string) error {
	_, err := q.db.Exec(ctx, removeRole, roleName)
	return err
}

const updateRolePermissions = `-- name: UpdateRolePermissions :exec
WITH updated_permission AS (
    UPDATE permissions
    SET
        is_administrator = $2,
        view_assets = $3,
        manage_assets = $4,
        view_modules = $5,
        create_modules = $6,
        manage_modules = $7,
        view_scans = $8,
        start_scans = $9
    WHERE
        permission_id = (
            SELECT rp.permission_id
            FROM roles_permissions rp
            JOIN roles r ON rp.role_id = r.role_id
            WHERE r.role_name = $1
            LIMIT 1
        )
    RETURNING permission_id
)
UPDATE roles_permissions rp
SET
    permission_id = updated_permission.permission_id
FROM updated_permission
WHERE rp.permission_id != updated_permission.permission_id
  AND rp.role_id = (
    SELECT r.role_id
    FROM roles r
    WHERE r.role_name = $1
    LIMIT 1
  )
`

type UpdateRolePermissionsParams struct {
	RoleName        string
	IsAdministrator pgtype.Bool
	ViewAssets      pgtype.Bool
	ManageAssets    pgtype.Bool
	ViewModules     pgtype.Bool
	CreateModules   pgtype.Bool
	ManageModules   pgtype.Bool
	ViewScans       pgtype.Bool
	StartScans      pgtype.Bool
}

func (q *Queries) UpdateRolePermissions(ctx context.Context, arg UpdateRolePermissionsParams) error {
	_, err := q.db.Exec(ctx, updateRolePermissions,
		arg.RoleName,
		arg.IsAdministrator,
		arg.ViewAssets,
		arg.ManageAssets,
		arg.ViewModules,
		arg.CreateModules,
		arg.ManageModules,
		arg.ViewScans,
		arg.StartScans,
	)
	return err
}

const updateUserPermissions = `-- name: UpdateUserPermissions :exec
WITH updated_permission AS (
    UPDATE permissions
    SET
        is_administrator = $2,
        view_assets = $3,
        manage_assets = $4,
        view_modules = $5,
        create_modules = $6,
        manage_modules = $7,
        view_scans = $8,
        start_scans = $9
    WHERE
        permission_id = (
            SELECT permission_id
            FROM iam_user_permissions iup
            JOIN iam_accounts ia ON iup.iam_account_id = ia.account_id
            WHERE ia.username = $1
        )
    RETURNING permission_id
)
UPDATE iam_user_permissions iup
SET
    permission_id = updated_permission.permission_id
FROM updated_permission
JOIN iam_accounts ia ON iup.iam_account_id = ia.account_id
WHERE ia.username = $1
`

type UpdateUserPermissionsParams struct {
	Username        string
	IsAdministrator pgtype.Bool
	ViewAssets      pgtype.Bool
	ManageAssets    pgtype.Bool
	ViewModules     pgtype.Bool
	CreateModules   pgtype.Bool
	ManageModules   pgtype.Bool
	ViewScans       pgtype.Bool
	StartScans      pgtype.Bool
}

func (q *Queries) UpdateUserPermissions(ctx context.Context, arg UpdateUserPermissionsParams) error {
	_, err := q.db.Exec(ctx, updateUserPermissions,
		arg.Username,
		arg.IsAdministrator,
		arg.ViewAssets,
		arg.ManageAssets,
		arg.ViewModules,
		arg.CreateModules,
		arg.ManageModules,
		arg.ViewScans,
		arg.StartScans,
	)
	return err
}
