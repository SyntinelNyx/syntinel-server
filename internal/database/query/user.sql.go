// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIAMUser = `-- name: CreateIAMUser :exec
WITH new_user AS (
    INSERT INTO iam_accounts (
            root_account_id,
            email,
            username,
            password_hash,
            account_status
        )
    VALUES ($1, $2, $3, $4, $5)
    RETURNING account_id
),
selected_role AS (
    SELECT role_id
    FROM roles
    WHERE role_name = $6
)
INSERT INTO iam_user_roles (iam_account_id, role_id)
SELECT new_user.account_id,
    selected_role.role_id
FROM new_user,
    selected_role
`

type CreateIAMUserParams struct {
	RootAccountID pgtype.UUID
	Email         string
	Username      string
	PasswordHash  string
	AccountStatus string
	RoleName      string
}

func (q *Queries) CreateIAMUser(ctx context.Context, arg CreateIAMUserParams) error {
	_, err := q.db.Exec(ctx, createIAMUser,
		arg.RootAccountID,
		arg.Email,
		arg.Username,
		arg.PasswordHash,
		arg.AccountStatus,
		arg.RoleName,
	)
	return err
}

const deleteUserByAccountID = `-- name: DeleteUserByAccountID :exec
UPDATE iam_accounts
SET is_deleted = TRUE
WHERE account_id = $1
`

func (q *Queries) DeleteUserByAccountID(ctx context.Context, accountID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserByAccountID, accountID)
	return err
}

const getAllIamUsers = `-- name: GetAllIamUsers :many
SELECT a.account_id,
    a.username,
    a.email,
    r.role_name
FROM iam_accounts a
    JOIN iam_user_roles ur ON ur.iam_account_id = a.account_id
    JOIN roles r ON r.role_id = ur.role_id
WHERE a.root_account_id = $1
    AND a.is_deleted = FALSE
`

type GetAllIamUsersRow struct {
	AccountID pgtype.UUID
	Username  string
	Email     string
	RoleName  string
}

func (q *Queries) GetAllIamUsers(ctx context.Context, rootAccountID pgtype.UUID) ([]GetAllIamUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllIamUsers, rootAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllIamUsersRow
	for rows.Next() {
		var i GetAllIamUsersRow
		if err := rows.Scan(
			&i.AccountID,
			&i.Username,
			&i.Email,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIAMAccountByID = `-- name: GetIAMAccountByID :one
SELECT a.account_id,
    a.email,
    a.username,
    r.role_name
FROM iam_accounts a
    JOIN iam_user_roles ur ON ur.iam_account_id = a.account_id
    JOIN roles r ON r.role_id = ur.role_id
WHERE a.account_id = $1
`

type GetIAMAccountByIDRow struct {
	AccountID pgtype.UUID
	Email     string
	Username  string
	RoleName  string
}

func (q *Queries) GetIAMAccountByID(ctx context.Context, accountID pgtype.UUID) (GetIAMAccountByIDRow, error) {
	row := q.db.QueryRow(ctx, getIAMAccountByID, accountID)
	var i GetIAMAccountByIDRow
	err := row.Scan(
		&i.AccountID,
		&i.Email,
		&i.Username,
		&i.RoleName,
	)
	return i, err
}

const getRootAccountIDAsIam = `-- name: GetRootAccountIDAsIam :one
SELECT root_account_id::UUID
FROM iam_accounts ia
WHERE ia.account_id = $1
`

func (q *Queries) GetRootAccountIDAsIam(ctx context.Context, accountID pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getRootAccountIDAsIam, accountID)
	var root_account_id pgtype.UUID
	err := row.Scan(&root_account_id)
	return root_account_id, err
}

const updateIAMUser = `-- name: UpdateIAMUser :exec
WITH new_role AS (
    SELECT role_id
    FROM roles
    WHERE role_name = $4
        AND is_deleted = FALSE
),
update_account AS (
    UPDATE iam_accounts
    SET email = $2,
        username = $3
    WHERE account_id = $1
),
update_role AS (
    UPDATE iam_user_roles
    SET role_id = (
            SELECT role_id
            FROM new_role
        )
    WHERE iam_account_id = $1
)
SELECT 1
`

type UpdateIAMUserParams struct {
	AccountID pgtype.UUID
	Email     string
	Username  string
	RoleName  string
}

func (q *Queries) UpdateIAMUser(ctx context.Context, arg UpdateIAMUserParams) error {
	_, err := q.db.Exec(ctx, updateIAMUser,
		arg.AccountID,
		arg.Email,
		arg.Username,
		arg.RoleName,
	)
	return err
}
