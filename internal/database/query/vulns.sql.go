// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vulns.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addNewVulnerabilities = `-- name: AddNewVulnerabilities :exec
INSERT INTO vulnerabilities (
        cve_id,
        vulnerability_name,
        vulnerability_description,
        vulnerability_severity,
        cvss_score,
        reference
    )
SELECT vuln->>'CVE_ID',
    vuln->>'VulnerabilityName',
    vuln->>'VulnerabilityDescription',
    vuln->>'VulnerabilitySeverity',
    (vuln->>'CVSSScore')::float,
    -- Handle the References field as an array, default to empty array if not an array
    CASE
        WHEN jsonb_typeof(vuln->'References') = 'array' THEN ARRAY(
            SELECT jsonb_array_elements_text(vuln->'References')
        )
        ELSE ARRAY []::text [] -- Empty array if it's not an array
    END AS reference
FROM jsonb_array_elements($1::jsonb) AS vuln ON CONFLICT (cve_id) DO NOTHING
`

func (q *Queries) AddNewVulnerabilities(ctx context.Context, vulnerabilities []byte) error {
	_, err := q.db.Exec(ctx, addNewVulnerabilities, vulnerabilities)
	return err
}

const calculateNewVulnerabilities = `-- name: CalculateNewVulnerabilities :exec
SELECT cve_id
FROM unnest($2) AS current_cves(cve_id)
WHERE cve_id NOT IN (
        SELECT avs.cve_id
        FROM asset_vulnerability_state avs
            JOIN assets a ON a.asset_id = avs.asset_id
            JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
        WHERE avs.asset_id = $1
    )
`

type CalculateNewVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateNewVulnerabilities(ctx context.Context, arg CalculateNewVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateNewVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const calculateNotAffectedVulnerabilities = `-- name: CalculateNotAffectedVulnerabilities :exec
SELECT avs.vulnerability_id
FROM asset_vulnerability_state avs
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
WHERE a.asset_id = $1
    AND avs.cve_id IN (
        SELECT unnest($2)
    )
    AND vulnerability_state != 'resolved'
`

type CalculateNotAffectedVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateNotAffectedVulnerabilities(ctx context.Context, arg CalculateNotAffectedVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateNotAffectedVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const calculateResolvedVulnerabilities = `-- name: CalculateResolvedVulnerabilities :exec
SELECT avs.vulnerability_id
FROM asset_vulnerability_state avs
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
WHERE a.asset_id = $1
    AND avs.cve_id NOT IN (
        SELECT unnest($2)
    )
    AND vulnerability_state != 'resolved'
`

type CalculateResolvedVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateResolvedVulnerabilities(ctx context.Context, arg CalculateResolvedVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateResolvedVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const calculateResurfacedVulnerabilities = `-- name: CalculateResurfacedVulnerabilities :exec
SELECT avs.vulnerability_id
FROM asset_vulnerability_state avs
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
WHERE a.asset_id = $1
    AND avs.cve_id IN (
        SELECT unnest($2)
    )
    AND vulnerability_state = 'resolved'
`

type CalculateResurfacedVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateResurfacedVulnerabilities(ctx context.Context, arg CalculateResurfacedVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateResurfacedVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const getVulnerabilities = `-- name: GetVulnerabilities :many
SELECT cve_id,
    vulnerability_name,
    vulnerability_severity,
    cvss_score
FROM vulnerabilities
`

type GetVulnerabilitiesRow struct {
	CveID                 string
	VulnerabilityName     string
	VulnerabilitySeverity pgtype.Text
	CvssScore             pgtype.Numeric
}

func (q *Queries) GetVulnerabilities(ctx context.Context) ([]GetVulnerabilitiesRow, error) {
	rows, err := q.db.Query(ctx, getVulnerabilities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVulnerabilitiesRow
	for rows.Next() {
		var i GetVulnerabilitiesRow
		if err := rows.Scan(
			&i.CveID,
			&i.VulnerabilityName,
			&i.VulnerabilitySeverity,
			&i.CvssScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePreviouslySeenVulnerabilities = `-- name: UpdatePreviouslySeenVulnerabilities :many
WITH current_vulns AS (
    SELECT unnest($3::text []) AS cve_id
),
updated AS (
    UPDATE asset_vulnerability_state avs
    SET scan_id = $2,
        vulnerability_state = CASE
            WHEN v.cve_id NOT IN (
                SELECT cve_id
                FROM current_vulns
            )
            AND avs.vulnerability_state != 'Resolved' THEN 'Resolved'
            WHEN v.cve_id IN (
                SELECT cve_id
                FROM current_vulns
            )
            AND avs.vulnerability_state = 'Resolved' THEN 'Resurfaced'
            WHEN v.cve_id IN (
                SELECT cve_id
                FROM current_vulns
            )
            AND avs.vulnerability_state = 'New' THEN 'Active'
            ELSE avs.vulnerability_state
        END
    FROM vulnerabilities v
    WHERE avs.asset_id = $1
        AND avs.vulnerability_id = v.vulnerability_id
),
new_vulns AS (
    SELECT cve_id
    FROM current_vulns
    WHERE cve_id NOT IN (
            SELECT cve_id
            FROM vulnerabilities
        )
)
SELECT cve_id::TEXT
FROM new_vulns
`

type UpdatePreviouslySeenVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	ScanID  pgtype.UUID
	CveList []string
}

func (q *Queries) UpdatePreviouslySeenVulnerabilities(ctx context.Context, arg UpdatePreviouslySeenVulnerabilitiesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, updatePreviouslySeenVulnerabilities, arg.AssetID, arg.ScanID, arg.CveList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var cve_id string
		if err := rows.Scan(&cve_id); err != nil {
			return nil, err
		}
		items = append(items, cve_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
