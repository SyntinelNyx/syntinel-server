// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vulns.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const batchUpdateVulnerabilityData = `-- name: BatchUpdateVulnerabilityData :exec
UPDATE vulnerabilities
SET vulnerability_name = vuln->>'Name',
    vulnerability_description = vuln->>'Description',
    vulnerability_severity = vuln->>'Severity',
    cvss_score = (vuln->>'CVSSScore')::float,
    created_on = (vuln->>'CreatedOn')::timestamptz,
    last_modified = (vuln->>'LastModified')::timestamptz,
    reference = CASE
        WHEN jsonb_typeof(vuln->'References') = 'array' THEN ARRAY(
            SELECT jsonb_array_elements_text(vuln->'References')
        )
        ELSE ARRAY []::text []
    END
FROM jsonb_array_elements($1::jsonb) AS vuln
WHERE vulnerabilities.vulnerability_id = vuln->>'ID'
`

func (q *Queries) BatchUpdateVulnerabilityData(ctx context.Context, vulnerabilities []byte) error {
	_, err := q.db.Exec(ctx, batchUpdateVulnerabilityData, vulnerabilities)
	return err
}

const batchUpdateVulnerabilityState = `-- name: BatchUpdateVulnerabilityState :exec
UPDATE vulnerabilities v
SET vulnerability_state = CASE
        WHEN vl.vulnerability_id IS NULL
        AND v.vulnerability_state != 'Resolved' THEN 'Resolved'
        WHEN vl.vulnerability_id IS NOT NULL
        AND v.vulnerability_state = 'Resolved' THEN 'Resurfaced'
        ELSE v.vulnerability_state
    END
FROM (
        SELECT unnest($1::text []) AS vulnerability_id
    ) AS vl
WHERE v.vulnerability_id = vl.vulnerability_id
    OR v.vulnerability_state != 'Resolved'
`

func (q *Queries) BatchUpdateVulnerabilityState(ctx context.Context, vulnList []string) error {
	_, err := q.db.Exec(ctx, batchUpdateVulnerabilityState, vulnList)
	return err
}

const calculateNewVulnerabilities = `-- name: CalculateNewVulnerabilities :exec
SELECT id
FROM unnest($2) AS current_vulns(id)
WHERE id NOT IN (
        SELECT avs.id
        FROM asset_vulnerability_state avs
            JOIN assets a ON a.asset_id = avs.asset_id
            JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
        WHERE avs.asset_id = $1
    )
`

type CalculateNewVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateNewVulnerabilities(ctx context.Context, arg CalculateNewVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateNewVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const calculateNotAffectedVulnerabilities = `-- name: CalculateNotAffectedVulnerabilities :exec
SELECT avs.vulnerability_id
FROM asset_vulnerability_state avs
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
WHERE a.asset_id = $1
    AND avs.id IN (
        SELECT unnest($2)
    )
    AND vulnerability_state != 'resolved'
`

type CalculateNotAffectedVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateNotAffectedVulnerabilities(ctx context.Context, arg CalculateNotAffectedVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateNotAffectedVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const calculateResolvedVulnerabilities = `-- name: CalculateResolvedVulnerabilities :exec
SELECT avs.vulnerability_id
FROM asset_vulnerability_state avs
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
WHERE a.asset_id = $1
    AND avs.id NOT IN (
        SELECT unnest($2)
    )
    AND vulnerability_state != 'resolved'
`

type CalculateResolvedVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateResolvedVulnerabilities(ctx context.Context, arg CalculateResolvedVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateResolvedVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const calculateResurfacedVulnerabilities = `-- name: CalculateResurfacedVulnerabilities :exec
SELECT avs.vulnerability_id
FROM asset_vulnerability_state avs
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN vulnerabilities v ON v.vulnerability_id = avs.vulnerability_id
WHERE a.asset_id = $1
    AND avs.id IN (
        SELECT unnest($2)
    )
    AND vulnerability_state = 'resolved'
`

type CalculateResurfacedVulnerabilitiesParams struct {
	AssetID pgtype.UUID
	Unnest  interface{}
}

func (q *Queries) CalculateResurfacedVulnerabilities(ctx context.Context, arg CalculateResurfacedVulnerabilitiesParams) error {
	_, err := q.db.Exec(ctx, calculateResurfacedVulnerabilities, arg.AssetID, arg.Unnest)
	return err
}

const getVulnerabilities = `-- name: GetVulnerabilities :many
SELECT vulnerability_uuid, vulnerability_id, vulnerability_name, vulnerability_description, vulnerability_severity, cvss_score, reference, created_on, last_modified, vulnerability_state
FROM vulnerabilities
`

func (q *Queries) GetVulnerabilities(ctx context.Context) ([]Vulnerability, error) {
	rows, err := q.db.Query(ctx, getVulnerabilities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vulnerability
	for rows.Next() {
		var i Vulnerability
		if err := rows.Scan(
			&i.VulnerabilityUuid,
			&i.VulnerabilityID,
			&i.VulnerabilityName,
			&i.VulnerabilityDescription,
			&i.VulnerabilitySeverity,
			&i.CvssScore,
			&i.Reference,
			&i.CreatedOn,
			&i.LastModified,
			&i.VulnerabilityState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNewVulnerabilities = `-- name: InsertNewVulnerabilities :exec
INSERT INTO vulnerabilities(vulnerability_id)
SELECT vulnerability_id
FROM unnest($1::text []) AS vulnerability_id
WHERE NOT EXISTS (
        SELECT 1
        FROM vulnerabilities v
        WHERE v.vulnerability_id = vulnerability_id
    )
`

func (q *Queries) InsertNewVulnerabilities(ctx context.Context, vulnList []string) error {
	_, err := q.db.Exec(ctx, insertNewVulnerabilities, vulnList)
	return err
}

const prepareVulnerabilityState = `-- name: PrepareVulnerabilityState :exec
UPDATE vulnerabilities
SET vulnerability_state = 'Active'
WHERE vulnerability_state = 'New'
`

func (q *Queries) PrepareVulnerabilityState(ctx context.Context) error {
	_, err := q.db.Exec(ctx, prepareVulnerabilityState)
	return err
}

const retrieveUnchangedVulnerabilities = `-- name: RetrieveUnchangedVulnerabilities :many
SELECT v.vulnerability_id
FROM unnest($1::text []) WITH ORDINALITY AS vuln(elem, ord)
    JOIN unnest($2::timestamptz []) WITH ORDINALITY AS mod(elem, ord) ON vuln.ord = mod.ord
    JOIN vulnerabilities v ON v.vulnerability_id = vuln.elem
WHERE v.last_modified >= mod.elem
`

type RetrieveUnchangedVulnerabilitiesParams struct {
	VulnList     []string
	ModifiedList []pgtype.Timestamptz
}

func (q *Queries) RetrieveUnchangedVulnerabilities(ctx context.Context, arg RetrieveUnchangedVulnerabilitiesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, retrieveUnchangedVulnerabilities, arg.VulnList, arg.ModifiedList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var vulnerability_id string
		if err := rows.Scan(&vulnerability_id); err != nil {
			return nil, err
		}
		items = append(items, vulnerability_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePreviouslySeenVulnerabilities = `-- name: UpdatePreviouslySeenVulnerabilities :many
WITH current_vulns AS (
    SELECT unnest($3::text []) AS id
),
updated AS (
    UPDATE asset_vulnerability_state avs
    SET scan_id = $2,
        vulnerability_state = CASE
            WHEN v.id NOT IN (
                SELECT id
                FROM current_vulns
            )
            AND avs.vulnerability_state != 'Resolved' THEN 'Resolved'
            WHEN v.id IN (
                SELECT id
                FROM current_vulns
            )
            AND avs.vulnerability_state = 'Resolved' THEN 'Resurfaced'
            WHEN v.id IN (
                SELECT id
                FROM current_vulns
            )
            AND avs.vulnerability_state = 'New' THEN 'Active'
            ELSE avs.vulnerability_state
        END
    FROM vulnerabilities v
    WHERE avs.asset_id = $1
        AND avs.vulnerability_id = v.vulnerability_id
),
new_vulns AS (
    SELECT id
    FROM current_vulns
    WHERE id NOT IN (
            SELECT id
            FROM vulnerabilities
        )
)
SELECT id::TEXT
FROM new_vulns
`

type UpdatePreviouslySeenVulnerabilitiesParams struct {
	AssetID  pgtype.UUID
	ScanID   pgtype.UUID
	VulnList []string
}

func (q *Queries) UpdatePreviouslySeenVulnerabilities(ctx context.Context, arg UpdatePreviouslySeenVulnerabilitiesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, updatePreviouslySeenVulnerabilities, arg.AssetID, arg.ScanID, arg.VulnList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
