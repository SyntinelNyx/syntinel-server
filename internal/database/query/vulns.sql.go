// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: vulns.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const batchUpdateVulnerabilityData = `-- name: BatchUpdateVulnerabilityData :exec
UPDATE vulnerability_data
SET vulnerability_name = vuln->>'Name',
    vulnerability_description = vuln->>'Description',
    vulnerability_severity = vuln->>'Severity',
    cvss_score = (vuln->>'CVSSScore')::float,
    created_on = (vuln->>'CreatedOn')::timestamptz,
    last_modified = (vuln->>'LastModified')::timestamptz,
    reference = CASE
        WHEN jsonb_typeof(vuln->'References') = 'array' THEN ARRAY(
            SELECT jsonb_array_elements_text(vuln->'References')
        )
        ELSE ARRAY []::text []
    END
FROM jsonb_array_elements($1::jsonb) AS vuln
WHERE vulnerability_data.vulnerability_id = vuln->>'VulnerabilityID'
`

func (q *Queries) BatchUpdateVulnerabilityData(ctx context.Context, vulnerabilities []byte) error {
	_, err := q.db.Exec(ctx, batchUpdateVulnerabilityData, vulnerabilities)
	return err
}

const batchUpdateVulnerabilityState = `-- name: BatchUpdateVulnerabilityState :exec
WITH root_account AS (
    SELECT COALESCE(
            (
                SELECT root_account_id
                FROM iam_accounts
                WHERE account_id = $1
                LIMIT 1
            ), $1
        ) AS id
),
vuln_list_data AS (
    SELECT vd.vulnerability_data_id
    FROM unnest($2::text []) AS vuln_id
        JOIN vulnerability_data vd ON vd.vulnerability_id = vuln_id
),
latest_state_history AS (
    SELECT DISTINCT ON (vuln_data_id) vuln_data_id,
        vulnerability_state
    FROM vulnerability_state_history
    WHERE root_account_id = (
            SELECT id
            FROM root_account
        )
    ORDER BY vuln_data_id,
        state_changed_at DESC
),
insert_active_and_resurfaced AS (
    INSERT INTO vulnerability_state_history (
            vuln_data_id,
            vulnerability_state,
            root_account_id
        )
    SELECT vl.vulnerability_data_id,
        CASE
            WHEN lsh.vulnerability_state = 'New' THEN 'Active'::vulnstate
            WHEN lsh.vulnerability_state = 'Resolved' THEN 'Resurfaced'::vulnstate
        END,
        (
            SELECT id
            FROM root_account
        )
    FROM vuln_list_data vl
        JOIN latest_state_history lsh ON lsh.vuln_data_id = vl.vulnerability_data_id
    WHERE lsh.vulnerability_state = 'New'
        OR lsh.vulnerability_state = 'Resolved'
),
insert_new_and_resolved AS (
    INSERT INTO vulnerability_state_history (
            vuln_data_id,
            vulnerability_state,
            root_account_id
        )
    SELECT COALESCE(
            vl.vulnerability_data_id,
            lsh.vuln_data_id
        ) AS vulnerability_data_id,
        CASE
            WHEN lsh.vuln_data_id IS NULL THEN 'New'::vulnstate
            WHEN vl.vulnerability_data_id IS NULL THEN 'Resolved'::vulnstate
        END AS state_change,
        (
            SELECT id
            FROM root_account
        )
    FROM vuln_list_data vl
        FULL OUTER JOIN latest_state_history lsh ON lsh.vuln_data_id = vl.vulnerability_data_id
    WHERE (
            lsh.vulnerability_state IS NULL
            OR (
                vl.vulnerability_data_id IS NULL
                AND lsh.vulnerability_state != 'Resolved'
            )
        )
)
SELECT 1
`

type BatchUpdateVulnerabilityStateParams struct {
	AccountID pgtype.UUID
	VulnList  []string
}

func (q *Queries) BatchUpdateVulnerabilityState(ctx context.Context, arg BatchUpdateVulnerabilityStateParams) error {
	_, err := q.db.Exec(ctx, batchUpdateVulnerabilityState, arg.AccountID, arg.VulnList)
	return err
}

const getVulnerabilities = `-- name: GetVulnerabilities :many
WITH root_account AS (
    SELECT COALESCE(
            (
                SELECT root_account_id
                FROM iam_accounts
                WHERE account_id = $1
                LIMIT 1
            ), $1
        ) AS id
),
latest_state_history AS (
    SELECT vuln_data_id,
        vulnerability_state
    FROM (
            SELECT history_id, vuln_data_id, vulnerability_state, state_changed_at, root_account_id,
                ROW_NUMBER() OVER (
                    PARTITION BY vuln_data_id
                    ORDER BY state_changed_at DESC
                ) AS rn
            FROM vulnerability_state_history
            WHERE root_account_id = (
                    SELECT id
                    FROM root_account
                )
        ) latest
    WHERE rn = 1
)
SELECT vulnerability_data_id, vulnerability_id, vulnerability_name, vulnerability_description, vulnerability_severity, reference, cvss_score, created_on, last_modified, vuln_data_id, vulnerability_state
FROM vulnerability_data
    JOIN latest_state_history lsh ON lsh.vuln_data_id = vulnerability_data.vulnerability_data_id
`

type GetVulnerabilitiesRow struct {
	VulnerabilityDataID      pgtype.UUID
	VulnerabilityID          string
	VulnerabilityName        pgtype.Text
	VulnerabilityDescription pgtype.Text
	VulnerabilitySeverity    pgtype.Text
	Reference                []string
	CvssScore                pgtype.Numeric
	CreatedOn                pgtype.Timestamptz
	LastModified             pgtype.Timestamptz
	VulnDataID               pgtype.UUID
	VulnerabilityState       Vulnstate
}

func (q *Queries) GetVulnerabilities(ctx context.Context, accountID pgtype.UUID) ([]GetVulnerabilitiesRow, error) {
	rows, err := q.db.Query(ctx, getVulnerabilities, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVulnerabilitiesRow
	for rows.Next() {
		var i GetVulnerabilitiesRow
		if err := rows.Scan(
			&i.VulnerabilityDataID,
			&i.VulnerabilityID,
			&i.VulnerabilityName,
			&i.VulnerabilityDescription,
			&i.VulnerabilitySeverity,
			&i.Reference,
			&i.CvssScore,
			&i.CreatedOn,
			&i.LastModified,
			&i.VulnDataID,
			&i.VulnerabilityState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVulnerabilitiesStateHistory = `-- name: GetVulnerabilitiesStateHistory :many
SELECT history_id, vuln_data_id, vulnerability_state, state_changed_at, root_account_id
FROM vulnerability_state_history
`

func (q *Queries) GetVulnerabilitiesStateHistory(ctx context.Context) ([]VulnerabilityStateHistory, error) {
	rows, err := q.db.Query(ctx, getVulnerabilitiesStateHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VulnerabilityStateHistory
	for rows.Next() {
		var i VulnerabilityStateHistory
		if err := rows.Scan(
			&i.HistoryID,
			&i.VulnDataID,
			&i.VulnerabilityState,
			&i.StateChangedAt,
			&i.RootAccountID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNewVulnerabilities = `-- name: InsertNewVulnerabilities :exec
INSERT INTO vulnerability_data(vulnerability_id)
SELECT unnest($1::text []) ON CONFLICT (vulnerability_id) DO NOTHING
`

func (q *Queries) InsertNewVulnerabilities(ctx context.Context, vulnList []string) error {
	_, err := q.db.Exec(ctx, insertNewVulnerabilities, vulnList)
	return err
}

const retrieveUnchangedVulnerabilities = `-- name: RetrieveUnchangedVulnerabilities :many
SELECT vd.vulnerability_id
FROM unnest($1::text []) WITH ORDINALITY AS vuln(elem, ord)
    JOIN unnest($2::timestamptz []) WITH ORDINALITY AS mod(elem, ord) ON vuln.ord = mod.ord
    JOIN vulnerability_data vd ON vd.vulnerability_id = vuln.elem
WHERE vd.last_modified >= mod.elem
`

type RetrieveUnchangedVulnerabilitiesParams struct {
	VulnList     []string
	ModifiedList []pgtype.Timestamptz
}

func (q *Queries) RetrieveUnchangedVulnerabilities(ctx context.Context, arg RetrieveUnchangedVulnerabilitiesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, retrieveUnchangedVulnerabilities, arg.VulnList, arg.ModifiedList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var vulnerability_id string
		if err := rows.Scan(&vulnerability_id); err != nil {
			return nil, err
		}
		items = append(items, vulnerability_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const retrieveVulnData = `-- name: RetrieveVulnData :one
SELECT vulnerability_name,
    vulnerability_description,
    cvss_score,
    reference,
    created_on,
    last_modified
FROM vulnerability_data
WHERE vulnerability_id = $1
`

type RetrieveVulnDataRow struct {
	VulnerabilityName        pgtype.Text
	VulnerabilityDescription pgtype.Text
	CvssScore                pgtype.Numeric
	Reference                []string
	CreatedOn                pgtype.Timestamptz
	LastModified             pgtype.Timestamptz
}

func (q *Queries) RetrieveVulnData(ctx context.Context, vulnerabilityID string) (RetrieveVulnDataRow, error) {
	row := q.db.QueryRow(ctx, retrieveVulnData, vulnerabilityID)
	var i RetrieveVulnDataRow
	err := row.Scan(
		&i.VulnerabilityName,
		&i.VulnerabilityDescription,
		&i.CvssScore,
		&i.Reference,
		&i.CreatedOn,
		&i.LastModified,
	)
	return i, err
}

const retrieveVulnTable = `-- name: RetrieveVulnTable :many
WITH root_account AS (
    SELECT COALESCE(
            (
                SELECT root_account_id
                FROM iam_accounts
                WHERE account_id = $1
                LIMIT 1
            ), $1
        ) AS id
),
latest_state_history AS (
    SELECT vuln_data_id,
        vulnerability_state
    FROM vulnerability_state_history
    WHERE root_account_id = (
            SELECT id
            FROM root_account
        )
        AND state_changed_at = (
            SELECT MAX(state_changed_at)
            FROM vulnerability_state_history
            WHERE vuln_data_id = vulnerability_state_history.vuln_data_id
        )
),
last_seen_table AS (
    SELECT vulnerability_id,
        scan_date AS last_seen
    FROM asset_vulnerability_scan avs
    WHERE root_account_id = (
            SELECT id
            FROM root_account
        )
        AND scan_date = (
            SELECT MAX(scan_date)
            FROM asset_vulnerability_scan
            WHERE vulnerability_id = avs.vulnerability_id
        )
)
SELECT vd.vulnerability_data_id,
    vd.vulnerability_id,
    lsh.vulnerability_state,
    vd.vulnerability_severity,
    vd.cvss_score,
    array_agg(DISTINCT si.hostname)::TEXT [] AS assets_affected,
    lst.last_seen
FROM vulnerability_data vd
    JOIN latest_state_history lsh ON lsh.vuln_data_id = vd.vulnerability_data_id
    JOIN last_seen_table lst ON lst.vulnerability_id = vd.vulnerability_data_id
    JOIN asset_vulnerability_scan avs ON avs.vulnerability_id = vd.vulnerability_data_id
    JOIN assets a ON a.asset_id = avs.asset_id
    JOIN system_information si ON si.id = a.sysinfo_id
GROUP BY vd.vulnerability_data_id,
    vd.vulnerability_id,
    lsh.vulnerability_state,
    vd.vulnerability_severity,
    vd.cvss_score,
    lst.last_seen
ORDER BY vd.cvss_score DESC
`

type RetrieveVulnTableRow struct {
	VulnerabilityDataID   pgtype.UUID
	VulnerabilityID       string
	VulnerabilityState    Vulnstate
	VulnerabilitySeverity pgtype.Text
	CvssScore             pgtype.Numeric
	AssetsAffected        []string
	LastSeen              pgtype.Timestamptz
}

func (q *Queries) RetrieveVulnTable(ctx context.Context, accountID pgtype.UUID) ([]RetrieveVulnTableRow, error) {
	rows, err := q.db.Query(ctx, retrieveVulnTable, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RetrieveVulnTableRow
	for rows.Next() {
		var i RetrieveVulnTableRow
		if err := rows.Scan(
			&i.VulnerabilityDataID,
			&i.VulnerabilityID,
			&i.VulnerabilityState,
			&i.VulnerabilitySeverity,
			&i.CvssScore,
			&i.AssetsAffected,
			&i.LastSeen,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
