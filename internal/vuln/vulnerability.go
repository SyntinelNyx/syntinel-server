package vuln

import (
	"encoding/json"
	"fmt"
)

type Vulnerability struct {
	CVE_ID                   string
	VulnerabilityName        string
	VulnerabilityDescription string
	VulnerabilitySeverity    string
	CVSSScore                float64
	References               []string
}

func (v *Vulnerability) String() string {
	return fmt.Sprintf(
		"CVE ID: %s\nName: %s\nSeverity: %s\nCVSS Score: %.2f\nDescription: %s\nReferences:\n%s",
		v.CVE_ID,
		v.VulnerabilityName,
		v.VulnerabilitySeverity,
		v.CVSSScore,
		v.VulnerabilityDescription,
		formatReferences(v.References),
	)
}
func formatReferences(refs []string) string {
	if len(refs) == 0 {
		return "None"
	}
	result := ""
	for _, ref := range refs {
		result += fmt.Sprintf("%s\n", ref)
	}
	return result
}

func removeDuplicateStr(strSlice []string) []string {
	allKeys := make(map[string]bool)
	list := []string{}
	for _, item := range strSlice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			list = append(list, item)
		}
	}
	return list
}

func GetVulnerabilitiesJson(newCves []string, vulnerabilities []Vulnerability) ([]byte, error) {
	removeDuplicateStr(newCves)

	newCVEIDs := make(map[string]struct{})
	for _, cveID := range newCves {
		newCVEIDs[cveID] = struct{}{}
	}

	var newVulnerabilities []Vulnerability
	for _, vuln := range vulnerabilities {
		if _, isNew := newCVEIDs[vuln.CVE_ID]; isNew {
			newVulnerabilities = append(newVulnerabilities, vuln)
		}
	}

	vulnerabilitiesJSON, err := json.Marshal(newVulnerabilities)
	if err != nil {
		return nil, fmt.Errorf("error marshalling vulnerabilities to JSON: %w", err)
	}

	return vulnerabilitiesJSON, nil
}
